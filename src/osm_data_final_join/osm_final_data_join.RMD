---
title: "OSM Final Data Join"
author: "DSPG Business Innovation Team"
date: "7/10/2019"
output: 
  github_document: default
  html_document: default
---

```{r setup, include=FALSE, message = FALSE, warning = FALSE}
#Setting root directory
knitr::opts_knit$set(echo = TRUE,
                     root.dir = rprojroot::find_rstudio_root_file())

#Load Pacman for multiple package loads
if (!require("pacman")) install.packages(pacman)

#Need most updated dplyr if haven't already done this
#install.packages("dplyr") #need updated dplyr for sf objects

#Load all the good stuff
pacman::p_load(tidyverse, purrr, sf, sp, mapview, ggmap,
               patchwork, osmdata, mapview, traveltime,
               iterators, doParallel, foreach, parallel,
               geosphere)

#Controlling figure output in markdown
knitr::opts_chunk$set(
#  fig.height =   
  fig.width = 6,
#  fig.asp = .5,
  out.width = "90%",
#  out.height = 
  cache = TRUE,
  eval  = FALSE
)

#Set Theme for ggplot2
theme_set(theme_bw() + theme(plot.title = element_text(hjust = 0.5), legend.position = "bottom"))

#Set Scientific notation output for knitr
options(scipen = 999999)
```


```{r echo = FALSE}
#Define functions for OSM Use  
#Fairfax read OSM to output tibble (tidyr df)
osm_to_df <- function(key = "leisure", value = "playground", type = "point") {
#Read in playground data
read.df <- getbb("fairfax county", format_out = "polygon") %>%
  opq() %>%
  add_osm_feature(key = key, value = value) %>%
  osmdata_sf()
    
    if (type == "point" & !is.null(read.df$osm_points)) {
      
      lat.long.df <- do.call(rbind, st_geometry(read.df$osm_points)) %>% 
        as_tibble() %>% 
        setNames(c("longitude", "latitude")) %>%
        mutate(object_id = 1:nrow(.) %>% as.factor()) %>%
        dplyr::select(object_id, everything())
      
    } else if (type == "polygon" & !is.null(read.df$osm_polygons)) {
      
      poly.list <- do.call(rbind, st_geometry(read.df$osm_polygons)) %>%
        lapply(as.tibble)
      npolys    <- length(poly.list)
      
      lat.long.df <- tibble(
        object_id = 1:npolys %>% as.factor(),
        coord.df  = poly.list
        ) %>%
        unnest(coord.df) %>%
        rename(
        longitude = lon,
        latitude  = lat
        )
      
    } else if (type == "line" & !is.null(read.df$osm_lines)) {
      
      line.list <- do.call(list, st_geometry(read.df$osm_lines)) %>%
        lapply(., rbind) %>%
        lapply(., as.tibble)
      nlines    <- length(line.list)
      
      lat.long.df <- tibble(
        object_id = 1:nlines %>% as.factor(),
        coord.df  = line.list
        ) %>%
        unnest(coord.df) %>%
        rename(
        longitude = lon,
        latitude  = lat
        )
    } else {
      ifelse(is.null(read.df$osm_points), stop("key/value incorrect or object type is empty"), 
             ifelse(!(type %in% c("point", "polygon", "line")), stop("type is not point, polygon, or line"),
                    stop("object type is empty, try another")))
    }
  
  return(lat.long.df)
}

#Base Map Function
fairfax.gg <- function() {
fairfax.box <- getbb("fairfax county")
fairfax.boundary <- getbb("fairfax county", format_out = "polygon") %>%
  as.tibble() %>%
  rename(longitude = `V1`, latitude = `V2`)

#Grab the map info (many varieties)
fairfax.map <- get_map(location = fairfax.box, source="stamen", maptype="watercolor", crop = TRUE)

#ggmap and ggplot map and boundary
ff.map <- ggmap(fairfax.map) +
  geom_polygon(data = fairfax.boundary, aes(x = longitude, y = latitude), colour = "black", size = 1, alpha = 0.1) +
  labs(
    x = "Longitude",
    y = "Latitude"
  )
  return(ff.map)
}

#Point Visualization
osm_point_plot <- function(ff.map, obj, value) {
  if (!is.data.frame(obj)) stop("OSM object is not a data frame")
  if (!is.ggplot(ff.map))  stop("Baseline Fairfax map is not a ggplot")
  ff.map +
  geom_point(data = obj, aes(x = longitude, y = latitude),
             size = 0.1, colour = "red", alpha = 0.25) + 
  geom_density_2d(data = obj, aes(x = longitude, y = latitude),
                  colour = "purple", alpha = 0.5) +
  labs(title = sprintf("Fairfax County %s", value))
  }

#Polygon Plot
osm_poly_plot <- function(ff.map, obj, value) {
  if (!is.data.frame(obj)) stop("OSM object is not a data frame")
  if (!is.ggplot(ff.map))  stop("Baseline Fairfax map is not a ggplot")
  ff.map +
  geom_polygon(data = obj, aes(x = longitude, y = latitude, group = object_id), 
               colour = "red", fill = "maroon", alpha = 0.5, size = 0.2) +
  labs(title = sprintf("Fairfax County %s", value))
  }

#Line Plot
osm_line_plot <- function(ff.map, obj, value) {
  if (!is.data.frame(obj)) stop("OSM object is not a data frame")
  if (!is.ggplot(ff.map))  stop("Baseline Fairfax map is not a ggplot")
  ff.map +
  geom_path(data = obj, aes(x = longitude, y = latitude, group = object_id), 
               colour = "red", alpha = 0.5, size = 0.5) +
  labs(title = sprintf("Fairfax County %s", value))
  }

#File Path Generator (for OSM specifically)
osm_filepath_gen <- function(data.folder, file.type, key, value, type) {
  date <- Sys.Date() %>% as.character() %>% str_replace_all("-", "_")
  file.type <- "csv"
  data.folder <- "original/osm"
  file.path <- sprintf("./data/%s/%s_%s.%s", 
                     data.folder,
                     date, 
                     paste(key, value, type, sep = "_"),
                     file.type)
  return(file.path)
}
``` 

##1. Build OSM Data Frame for Mapping API Calls


Here we are generating a tibble with an environment (Food vs. Physical), variable, and nested list/tibble with columns key, value, type.   

```{r}
#Generate Food Environment Tibble (variable, key, value, type)
food.key.df <- tibble(
  variable = c("Fast Food", "Supermarket", rep("Convenience", times = 2), "Restaurant", "Gas Station", rep("Alcohol", times= 3)),
  key      = c("amenity", "shop", "shop", "shop", "amenity", "amenity", "shop", "amenity", "amenity"),
  value    = c("fast_food", "supermarket", "convenience", "greengrocer", "restaurant", "fuel", "alcohol", "bar", "pub"),
  type     = rep("point", times = length(value))
) %>%
  nest(-variable)

#Generate Physical Environment Tibble (variable, key, value, type)
phys.key.df <- tibble(
  variable = c("Playground", rep("Park", times = 3), "Swimming Pool", "Sports Center", "Track", rep("Team Sport", times = 4)),
  key      = c(rep("leisure", times = 3), "boundary", rep("leisure", times = 3), rep("sport", times = 4)),
  value    = c("playground", "park", "nature_reserve", "national_park", "swimming_pool", "sports_centre", "track", "baseball", "basketball", "soccer", "tennis"),
  type    = c("point", rep("polygon", times = 3), rep("point", times = 7))
) %>%
  nest(-variable)

#Join for total osm obesegenic tibble (now with environment indicator)
obese.df <- bind_rows(food.key.df,
                      phys.key.df) %>%
            mutate(
              environment = c(
                rep("Food",     times = nrow(food.key.df)),
                rep("Physical", times = nrow(phys.key.df))
              )
            ) %>%
            dplyr::select(environment, variable, everything())
#Display
head(obese.df) %>% knitr::kable()
```

##2. Map OSM API Call

Here, we are going to map over the nested key, value, type lists/tibbles *per variable*, to generate a tibble of the object_id, longitude, and latitude per each specific aspect of each variable (e.g. nature reserve vs. park, within the variable park). The resulting unnested frame will have 6 variables: environment, variable, object_id (specific aspect + number), longitude, and latitude.  

Here we retain all the factor identifiers so we can pass this to the distance-time API to generate our final index variables.  

####Disregard Points Outside Fairfax Boundary (for Computation)

Here we get the polygon defined by the FF boundary, and apply the `point.in.polygon` function from the `sp` package to keep only those inside Fairfax. This is because the data we obtained from OSM describes geolocations for objects in a square around fairfax, and all the housing data is inside fairfax, so looking at points outside is computationally inefficient. Actually, it also biases the proportional results. Thus restrict the scope of our OSM features to those within FF County.  

Example for Playgrounds
```{r}
#Define the Boundary
fairfax.boundary <- getbb("fairfax county", format_out = "polygon") %>%
  as_tibble() %>%
  rename(longitude = `V1`, latitude = `V2`)

#Example for Playgrounds
##Original with all points in sqaure grid around FF
nrow(osm_to_df())

##Trimmed set within FF
osm_to_df() %>% 
  mutate(in_fairfax = ifelse(
point.in.polygon(longitude, latitude, fairfax.boundary$longitude, fairfax.boundary$latitude) %in% 1, TRUE, FALSE
)) %>%
  filter(in_fairfax == TRUE) %>%
  select(-in_fairfax) %>%
  nrow()
```

####Build the Map function on the First OSM Observation

```{r}
import_osm <- function(tibble) {
  
  #Map import osm over rows of key, value, type tibble; rbind into cohesive output frame
  pmap_df(
    tibble,
    ~osm_to_df(key = ..1, value = ..2, type = ..3) %>%
          mutate(object_id = paste0(..2, object_id))
              ) %>% mutate(
                     in_fairfax = ifelse(point.in.polygon(longitude, latitude,
                                         fairfax.boundary$longitude,
                                         fairfax.boundary$latitude) %in% 1,
                                         TRUE,
                                         FALSE)
                     ) %>%
                      filter(in_fairfax == TRUE) %>%
                      select(-in_fairfax)
  #Output is a tibble with columns object_id (attribute + id), longitude, and latitude
  ###Where observations have been trimmed to those within the Fairfax County Boundary
}

#Now that we've built the necessary functions, time to map through all key, val pairs, nest into obese.df
obese.df <- obese.df %>%
  mutate(
    osm_df = map(data, import_osm)
  )

#View the head
head(obese.df) %>% knitr::kable()
```


####Unnest and Write out csv
```{r}
obese.df <- obese.df %>%
            unnest(osm_df)

dim(obese.df)
names(obese.df) %>% paste0(., collapse = ", ")

write_csv(obese.df, path = "./data/working/OSM_joined/7_10_2019_osm_joined.csv")

```